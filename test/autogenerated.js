var tape = require('tape')
var run = require('./helpers/run')
var put = require('./helpers/put')
var create = require('./helpers/create')
var validate = require('./helpers/fuzzing').validate
var EthCrypto = require('eth-crypto');
var identity0 = EthCrypto.createIdentity();
var identity1 = EthCrypto.createIdentity();

tape('autogenerated failing fuzz test #1', function (t) {
	var writesPerReplication = [
		[
			[identity1.publicKey + '/fefhe', [null, 'hgbbhiegadhdeegdebfa']],
			[identity0.publicKey + '/gjegc/gjegc', ['jegahfeddccagaaghgce']],
			[identity0.publicKey + '/gjegc/gidjb', ['jjbchagfijbhiiijcaig']],
			[identity0.publicKey + '/gjegc/feffb', ['eiebhdddigbhheaacjdj']],
			[identity1.publicKey + '/gjegc/feigc', [null, 'ajfgdihjedbcdhjgcaed']],
			[identity1.publicKey + '/gjegc/adifa', [null, 'fghhbhchhdbidbbbfabh']]
		],
		[
			[identity0.publicKey + '/gjegc/caghc', ['gfjcgaebibbccjceggej']],
			[identity1.publicKey + '/gjegc/ghbdb', [null, 'ggbddcahebaejbegaceh']],
			[identity0.publicKey + '/gjegc/aaahi/aaahi', ['bibggfheidahefhhgdci']]
		]
	].map(b => new Map(b))

	create.many(2, function (err, dbs, replicateByIndex) {
		t.error(err)
		run(
			cb => {
				put(
					dbs[1],
					identity1.privateKey,
					identity1.publicKey,
					[
						{
							key: identity1.publicKey + '/fefhe',
							value: 'hgbbhiegadhdeegdebfa'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[0],
					identity0.privateKey,
					identity0.publicKey,
					[
						{
							key: identity0.publicKey + '/gjegc/gjegc',
							value: 'jegahfeddccagaaghgce'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[0],
					identity0.privateKey,
					identity0.publicKey,
					[
						{
							key: identity0.publicKey + '/gjegc/gidjb',
							value: 'jjbchagfijbhiiijcaig'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[0],
					identity0.privateKey,
					identity0.publicKey,
					[
						{
							key: identity0.publicKey + '/gjegc/feffb',
							value: 'eiebhdddigbhheaacjdj'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[1],
					identity1.privateKey,
					identity1.publicKey,
					[
						{
							key: identity1.publicKey + '/gjegc/feigc',
							value: 'ajfgdihjedbcdhjgcaed'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[1],
					identity1.privateKey,
					identity1.publicKey,
					[
						{
							key: identity1.publicKey + '/gjegc/adifa',
							value: 'fghhbhchhdbidbbbfabh'
						}
					],
					cb
				)
			},
			cb => replicateByIndex(cb),
			cb => validate(t, dbs[0], writesPerReplication.slice(0, 1), cb),
			cb => {
				put(
					dbs[0],
					identity0.privateKey,
					identity0.publicKey,
					[
						{
							key: identity0.publicKey + '/gjegc/caghc',
							value: 'gfjcgaebibbccjceggej'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[1],
					identity1.privateKey,
					identity1.publicKey,
					[
						{
							key: identity1.publicKey + '/gjegc/ghbdb',
							value: 'ggbddcahebaejbegaceh'
						}
					],
					cb
				)
			},
			cb => {
				put(
					dbs[0],
					identity0.privateKey,
					identity0.publicKey,
					[
						{
							key: identity0.publicKey + '/gjegc/aaahi/aaahi',
							value: 'bibggfheidahefhhgdci'
						}
					],
					cb
				)
			},
			cb => replicateByIndex(cb),
			cb => validate(t, dbs[0], writesPerReplication.slice(0, 2), cb),
			err => {
				t.error(err)
				t.end()
			}
		)
	})
})
